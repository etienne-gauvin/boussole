(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _compass = require('./compass');

var _compass2 = _interopRequireDefault(_compass);

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Client = function () {
	function Client() {
		_classCallCheck(this, Client);

		this.socket = null;

		this.lastCoordinatesSentTime = -Infinity;

		this._position = 0;
		this._deviceDirection = 0;
		this._directionToTarget = 0;

		this.compass = new _compass2.default(document.querySelector('.compass'));
		this.compass.start();
	}

	_createClass(Client, [{
		key: 'start',
		value: function start() {

			this.connectToServer().then(this.watchOrientation.bind(this), this.error.bind(this)).then(this.watchPosition.bind(this), this.error.bind(this));
		}

		/** 
   * @return <Promise>
   */

	}, {
		key: 'connectToServer',
		value: function connectToServer() {
			var _this = this;

			return new Promise(function (resolve, reject) {

				_this.socket = io();

				var intervalFunctionId = void 0;

				_this.socket.on('connect', function () {

					console.info('Connected to server as ' + _this.socket.id);

					intervalFunctionId = window.setInterval(_this.sendCoordinates.bind(_this), 5000);

					resolve();
				});

				_this.socket.on('direction', function (direction) {

					console.info('Got new new direction from server:', direction);

					_this.directionToTarget = direction;
				});

				_this.socket.on('disconnect', function () {

					console.warn('Disconnected from server');

					window.clearInterval(intervalFunctionId);
				});

				_this.socket.on('error', function (error) {

					console.error(error);

					window.clearInterval(intervalFunctionId);

					reject(error);
				});
			});
		}

		/** 
   * @return <Promise>
   */

	}, {
		key: 'watchOrientation',
		value: function watchOrientation() {
			var _this2 = this;

			console.log('Getting orientation…');

			return new Promise(function (resolve, reject) {

				if (window.DeviceOrientationEvent) {

					var gotOrientationOnce = false;

					window.addEventListener('deviceorientation', function (event) {

						_this2.deviceDirection = event.alpha;

						_this2.compass.angle = _this2.deviceDirection + _this2.directionToTarget;

						if (!gotOrientationOnce) {

							gotOrientationOnce = true;

							console.log('Got orientation!', _this2.deviceDirection);

							resolve();
						}
					});
				} else reject("La boussole n'est pas disponible.");
			});
		}
	}, {
		key: 'watchPosition',
		value: function watchPosition() {
			var _this3 = this;

			console.log('Getting position…');

			return new Promise(function (resolve, reject) {

				if (window.navigator.geolocation) {

					var parameters = {
						enableHighAccuracy: true,
						maximumAge: 30000,
						timeout: 27000
					};

					var gotPositionOnce = false;

					window.navigator.geolocation.watchPosition(function (position) {

						_this3.position = position;

						if (!gotPositionOnce) {

							gotPositionOnce = true;

							console.log('Got position!', _this3.position);

							resolve();
						}
					}, function () {
						return reject("Le service de géolocalisation n'est pas disponible.");
					}, parameters);
				} else reject("Le service de géolocalisation n'est pas disponible.");
			});
		}

		/**
   * Send coordinates
   */

	}, {
		key: 'sendCoordinates',
		value: function sendCoordinates() {

			var position = this.position;

			if (this.connected && position) {

				console.log('Sending new coords to server:', position.coords);

				this.socket.emit('coordinates', position.coords);
			}
		}

		/**
   * 
   */

	}, {
		key: 'update',
		value: function update() {

			var now = +new Date();

			if (this.lastCoordinatesSentTime < now - 5000) {

				this.lastCoordinatesSentTime = now;
				this.sendCoordinates();
			}
		}

		/**
   * Error
   */

	}, {
		key: 'error',
		value: function error(message) {

			console.error(message);
		}
	}, {
		key: 'directionToTarget',
		get: function get() {

			return this._directionToTarget;
		},
		set: function set(directionToTarget) {

			this._directionToTarget = directionToTarget;

			this.update();
		}
	}, {
		key: 'deviceDirection',
		get: function get() {

			return this._deviceDirection;
		},
		set: function set(deviceDirection) {

			this._deviceDirection = deviceDirection;

			this.update();
		}
	}, {
		key: 'position',
		get: function get() {

			return this._position;
		},
		set: function set(position) {

			this._position = position;

			this.update();
		}
	}, {
		key: 'connected',
		get: function get() {

			return this.socket && this.socket.connected;
		}
	}]);

	return Client;
}();

exports.default = Client;

},{"./compass":2,"./utils":4}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
		value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Compass = function () {
		function Compass(element) {
				_classCallCheck(this, Compass);

				this.needleElement = element.querySelector('.red.needle');

				// Last angle
				this.targetedAngle = 0;

				// Visual angle of the needle
				this.visibleAngle = 0;

				// Needle velocity 
				this.velocity = 0;

				// Last time a frame was updated
				this.lastTime = +new Date();

				// Last time the velocity was updated
				this.lastVelocityUpdateTime = -Infinity;
		}

		/**
   * Évènements
   */


		_createClass(Compass, [{
				key: 'start',
				value: function start() {

						window.requestAnimationFrame(this.update.bind(this));
				}

				/**
     * Nouvel angle donné par le device
     * @param <Number> angle
     */

		}, {
				key: 'updateVelocity',


				/** 
     * Updating velocity
     * Separate from display update for performance
     */
				value: function updateVelocity() {

						var diff = _utils2.default.calculateAngleBetweenDirections(this.targetedAngle, this.visibleAngle);

						this.velocity = this.velocity * 0.5 + diff * 2;
				}

				/**
     * Update visible angle of the needle
     * @param <Number> time
     */

		}, {
				key: 'update',
				value: function update(time) {

						this.visibleAngle += this.velocity * ((time - this.lastTime) / 1000);

						this.needleElement.style.transform = 'rotate(' + this.visibleAngle + 'deg)';

						this.lastTime = time;

						if (time - this.lastVelocityUpdateTime > 200) {

								this.lastVelocityUpdateTime = time;

								this.updateVelocity();
						}

						window.requestAnimationFrame(this.update.bind(this));
				}
		}, {
				key: 'angle',
				set: function set(angle) {

						var now = +new Date();

						// Difference between the last two angles
						var diff = _utils2.default.calculateAngleBetweenDirections(angle, this.targetedAngle);

						// New angle -+Infini
						// to avoid strange transitions
						// (the needle doing a full circle between 350° and 10°, for example)
						this.targetedAngle += diff;
				}

				/**
    * @return <Number>
     */
				,
				get: function get() {

						return this.targetedAngle;
				}
		}]);

		return Compass;
}();

exports.default = Compass;

},{"./utils":4}],3:[function(require,module,exports){
'use strict';

var _client = require('./client');

var _client2 = _interopRequireDefault(_client);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

document.addEventListener('DOMContentLoaded', function (event) {

	var client = new _client2.default();

	client.start();
});

},{"./client":1}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = {

	/**
  * Calculate difference between two angles (360)
  * @param <Number> origin
  * @param <Number> target
  * @return <Number>
  */
	calculateAngleBetweenDirections: function calculateAngleBetweenDirections(origin, target) {

		var n = origin - target + 180;

		return n - Math.floor(n / 360) * 360 - 180;
	},


	/**
  * Calculate angle between two coordinates
  * @param <Coordinates> origin
  * @param <Coordinates> target
  * @return <Number> angle in degrees
  */
	calculateDirectionToCoordinates: function calculateDirectionToCoordinates(origin, target) {

		var cos = Math.cos,
		    sin = Math.sin;

		var distance = target.longitude - origin.longitude;

		var y = sin(distance) * cos(target.latitude);

		var x = cos(origin.latitude) * sin(target.latitude) - sin(origin.latitude) * cos(target.latitude) * cos(distance);

		var angle = Math.atan2(y, x);

		// Radians to degrees
		angle *= 180 / Math.PI;

		angle = (angle + 360) % 360;

		angle = 360 - angle; // count degrees counter-clockwise - remove to make clockwise

		return angle;
	}
};

},{}]},{},[3])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjbGllbnRcXGphdmFzY3JpcHRzXFxjbGllbnQuanMiLCJjbGllbnRcXGphdmFzY3JpcHRzXFxjb21wYXNzLmpzIiwiY2xpZW50XFxqYXZhc2NyaXB0c1xcbWFpbi5qcyIsImNsaWVudFxcamF2YXNjcmlwdHNcXHV0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7QUNBQTs7OztBQUNBOzs7Ozs7OztJQUVxQixNO0FBRXBCLG1CQUFjO0FBQUE7O0FBRWIsT0FBSyxNQUFMLEdBQWMsSUFBZDs7QUFFQSxPQUFLLHVCQUFMLEdBQStCLENBQUMsUUFBaEM7O0FBRUEsT0FBSyxTQUFMLEdBQWlCLENBQWpCO0FBQ0EsT0FBSyxnQkFBTCxHQUF3QixDQUF4QjtBQUNBLE9BQUssa0JBQUwsR0FBMEIsQ0FBMUI7O0FBRUEsT0FBSyxPQUFMLEdBQWUsc0JBQVksU0FBUyxhQUFULENBQXVCLFVBQXZCLENBQVosQ0FBZjtBQUNBLE9BQUssT0FBTCxDQUFhLEtBQWI7QUFFQTs7OzswQkFrRE87O0FBRVAsUUFBSyxlQUFMLEdBQ0UsSUFERixDQUNPLEtBQUssZ0JBQUwsQ0FBc0IsSUFBdEIsQ0FBMkIsSUFBM0IsQ0FEUCxFQUN5QyxLQUFLLEtBQUwsQ0FBVyxJQUFYLENBQWdCLElBQWhCLENBRHpDLEVBRUUsSUFGRixDQUVPLEtBQUssYUFBTCxDQUFtQixJQUFuQixDQUF3QixJQUF4QixDQUZQLEVBRXNDLEtBQUssS0FBTCxDQUFXLElBQVgsQ0FBZ0IsSUFBaEIsQ0FGdEM7QUFJQTs7QUFFRDs7Ozs7O29DQUdrQjtBQUFBOztBQUVqQixVQUFPLElBQUksT0FBSixDQUFZLFVBQUMsT0FBRCxFQUFVLE1BQVYsRUFBcUI7O0FBRXZDLFVBQUssTUFBTCxHQUFjLElBQWQ7O0FBRUEsUUFBSSwyQkFB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QUVkOzs7Ozs7QUFNQSxnQ0FSYywyQ0FRa0IsTUFSbEIsRUFRMEIsTUFSMUIsRUFRa0M7O0FBRS9DLE1BQU0sSUFBSSxTQUFTLE1BQVQsR0FBa0IsR0FBNUI7O0FBRUEsU0FBUSxJQUFJLEtBQUssS0FBTCxDQUFXLElBQUksR0FBZixJQUFzQixHQUEzQixHQUFrQyxHQUF6QztBQUVBLEVBZGE7OztBQWdCZDs7Ozs7O0FBTUEsZ0NBdEJjLDJDQXNCa0IsTUF0QmxCLEVBc0IwQixNQXRCMUIsRUFzQmtDOztBQUUvQyxNQUFNLE1BQU0sS0FBSyxHQUFqQjtBQUFBLE1BQXNCLE1BQU0sS0FBSyxHQUFqQzs7QUFFQSxNQUFNLFdBQVksT0FBTyxTQUFQLEdBQW1CLE9BQU8sU0FBNUM7O0FBRUEsTUFBTSxJQUFJLElBQUksUUFBSixJQUFnQixJQUFJLE9BQU8sUUFBWCxDQUExQjs7QUFFQSxNQUFNLElBQUksSUFBSSxPQUFPLFFBQVgsSUFBdUIsSUFBSSxPQUFPLFFBQVgsQ0FBdkIsR0FDTixJQUFJLE9BQU8sUUFBWCxJQUF1QixJQUFJLE9BQU8sUUFBWCxDQUF2QixHQUNBLElBQUksUUFBSixDQUZKOztBQUlHLE1BQUksUUFBUSxLQUFLLEtBQUwsQ0FBVyxDQUFYLEVBQWMsQ0FBZCxDQUFaOztBQUVBO0FBQ0EsV0FBUyxNQUFNLEtBQUssRUFBcEI7O0FBRUEsVUFBUSxDQUFDLFFBQVEsR0FBVCxJQUFnQixHQUF4Qjs7QUFFQSxVQUFRLE1BQU0sS0FBZCxDQW5CNEMsQ0FtQnZCOztBQUVyQixTQUFPLEtBQVA7QUFDSDtBQTVDYSxDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsImltcG9ydCBDb21wYXNzIGZyb20gJy4vY29tcGFzcydcclxuaW1wb3J0IHV0aWxzIGZyb20gJy4vdXRpbHMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDbGllbnQge1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHRcdFxyXG5cdFx0dGhpcy5zb2NrZXQgPSBudWxsXHJcblxyXG5cdFx0dGhpcy5sYXN0Q29vcmRpbmF0ZXNTZW50VGltZSA9IC1JbmZpbml0eVxyXG5cclxuXHRcdHRoaXMuX3Bvc2l0aW9uID0gMFxyXG5cdFx0dGhpcy5fZGV2aWNlRGlyZWN0aW9uID0gMFxyXG5cdFx0dGhpcy5fZGlyZWN0aW9uVG9UYXJnZXQgPSAwXHJcblxyXG5cdFx0dGhpcy5jb21wYXNzID0gbmV3IENvbXBhc3MoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbXBhc3MnKSlcclxuXHRcdHRoaXMuY29tcGFzcy5zdGFydCgpXHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IGRpcmVjdGlvblRvVGFyZ2V0KCkgeyBcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fZGlyZWN0aW9uVG9UYXJnZXRcclxuXHJcblx0fVxyXG5cclxuXHRzZXQgZGlyZWN0aW9uVG9UYXJnZXQoZGlyZWN0aW9uVG9UYXJnZXQpIHtcclxuXHJcblx0XHR0aGlzLl9kaXJlY3Rpb25Ub1RhcmdldCA9IGRpcmVjdGlvblRvVGFyZ2V0XHJcblxyXG5cdFx0dGhpcy51cGRhdGUoKVxyXG5cclxuXHR9XHJcblxyXG5cdGdldCBkZXZpY2VEaXJlY3Rpb24oKSB7IFxyXG5cclxuXHRcdHJldHVybiB0aGlzLl9kZXZpY2VEaXJlY3Rpb25cclxuXHJcblx0fVxyXG5cclxuXHRzZXQgZGV2aWNlRGlyZWN0aW9uKGRldmljZURpcmVjdGlvbikge1xyXG5cclxuXHRcdHRoaXMuX2RldmljZURpcmVjdGlvbiA9IGRldmljZURpcmVjdGlvblxyXG5cclxuXHRcdHRoaXMudXBkYXRlKClcclxuXHJcblx0fVxyXG5cclxuXHRnZXQgcG9zaXRpb24oKSB7IFxyXG5cclxuXHRcdHJldHVybiB0aGlzLl9wb3NpdGlvblxyXG5cclxuXHR9XHJcblxyXG5cdHNldCBwb3NpdGlvbihwb3NpdGlvbikge1xyXG5cclxuXHRcdHRoaXMuX3Bvc2l0aW9uID0gcG9zaXRpb25cclxuXHJcblx0XHR0aGlzLnVwZGF0ZSgpXHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IGNvbm5lY3RlZCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zb2NrZXQgJiYgdGhpcy5zb2NrZXQuY29ubmVjdGVkXHJcblxyXG5cdH1cclxuXHJcblx0c3RhcnQoKSB7XHJcblxyXG5cdFx0dGhpcy5jb25uZWN0VG9TZXJ2ZXIoKVxyXG5cdFx0XHQudGhlbih0aGlzLndhdGNoT3JpZW50YXRpb24uYmluZCh0aGlzKSwgdGhpcy5lcnJvci5iaW5kKHRoaXMpKVxyXG5cdFx0XHQudGhlbih0aGlzLndhdGNoUG9zaXRpb24uYmluZCh0aGlzKSwgdGhpcy5lcnJvci5iaW5kKHRoaXMpKVxyXG4gXHJcblx0fVxyXG5cclxuXHQvKiogXHJcblx0ICogQHJldHVybiA8UHJvbWlzZT5cclxuXHQgKi9cclxuXHRjb25uZWN0VG9TZXJ2ZXIoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuXHJcblx0XHRcdHRoaXMuc29ja2V0ID0gaW8oKVxyXG5cclxuXHRcdFx0bGV0IGludGVydmFsRnVuY3Rpb25JZFxyXG5cclxuXHRcdFx0dGhpcy5zb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUuaW5mbyhgQ29ubmVjdGVkIHRvIHNlcnZlciBhcyAke3RoaXMuc29ja2V0LmlkfWApXHJcblxyXG5cdFx0XHRcdGludGVydmFsRnVuY3Rpb25JZCA9IHdpbmRvdy5zZXRJbnRlcnZhbCh0aGlzLnNlbmRDb29yZGluYXRlcy5iaW5kKHRoaXMpLCA1MDAwKVxyXG5cclxuXHRcdFx0XHRyZXNvbHZlKClcclxuXHJcblx0XHRcdH0pXHJcblxyXG5cdFx0XHR0aGlzLnNvY2tldC5vbignZGlyZWN0aW9uJywgKGRpcmVjdGlvbikgPT4ge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmluZm8oJ0dvdCBuZXcgbmV3IGRpcmVjdGlvbiBmcm9tIHNlcnZlcjonLCBkaXJlY3Rpb24pXHJcblxyXG5cdFx0XHRcdHRoaXMuZGlyZWN0aW9uVG9UYXJnZXQgPSBkaXJlY3Rpb25cclxuXHJcblx0XHRcdH0pXHJcblx0XHRcdFxyXG5cdFx0XHR0aGlzLnNvY2tldC5vbignZGlzY29ubmVjdCcsICgpID0+IHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKGBEaXNjb25uZWN0ZWQgZnJvbSBzZXJ2ZXJgKVxyXG5cclxuXHRcdFx0XHR3aW5kb3cuY2xlYXJJbnRlcnZhbChpbnRlcnZhbEZ1bmN0aW9uSWQpXHJcblxyXG5cdFx0XHR9KVxyXG5cdFx0XHRcclxuXHRcdFx0dGhpcy5zb2NrZXQub24oJ2Vycm9yJywgKGVycm9yKSA9PiB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoZXJyb3IpXHJcblxyXG5cdFx0XHRcdHdpbmRvdy5jbGVhckludGVydmFsKGludGVydmFsRnVuY3Rpb25JZClcclxuXHJcblx0XHRcdFx0cmVqZWN0KGVycm9yKVxyXG5cclxuXHRcdFx0fSlcclxuXHJcblx0XHR9KVxyXG5cclxuXHR9XHJcblxyXG5cdC8qKiBcclxuXHQgKiBAcmV0dXJuIDxQcm9taXNlPlxyXG5cdCAqL1xyXG5cdHdhdGNoT3JpZW50YXRpb24oKSB7XHJcblxyXG5cdFx0Y29uc29sZS5sb2coJ0dldHRpbmcgb3JpZW50YXRpb27igKYnKVxyXG5cclxuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcblxyXG5cdFx0XHRpZiAod2luZG93LkRldmljZU9yaWVudGF0aW9uRXZlbnQpIHtcclxuXHJcblx0XHRcdFx0bGV0IGdvdE9yaWVudGF0aW9uT25jZSA9IGZhbHNlXHJcblxyXG5cdFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VvcmllbnRhdGlvbicsIGV2ZW50ID0+IHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLmRldmljZURpcmVjdGlvbiA9IGV2ZW50LmFscGhhXHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdHRoaXMuY29tcGFzcy5hbmdsZSA9IHRoaXMuZGV2aWNlRGlyZWN0aW9uICsgdGhpcy5kaXJlY3Rpb25Ub1RhcmdldFxyXG5cclxuXHRcdFx0XHRcdGlmICghZ290T3JpZW50YXRpb25PbmNlKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRnb3RPcmllbnRhdGlvbk9uY2UgPSB0cnVlXHJcblxyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZygnR290IG9yaWVudGF0aW9uIScsIHRoaXMuZGV2aWNlRGlyZWN0aW9uKVxyXG5cclxuXHRcdFx0XHRcdFx0cmVzb2x2ZSgpXHJcblxyXG5cdFx0XHRcdFx0fSBcclxuXHRcdFx0XHRcclxuXHRcdFx0XHR9KVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZWxzZSByZWplY3QoXCJMYSBib3Vzc29sZSBuJ2VzdCBwYXMgZGlzcG9uaWJsZS5cIilcclxuXHJcblx0XHR9KVxyXG5cclxuXHR9XHJcblxyXG5cdHdhdGNoUG9zaXRpb24oKSB7XHJcblxyXG5cdFx0Y29uc29sZS5sb2coJ0dldHRpbmcgcG9zaXRpb27igKYnKVxyXG5cclxuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcblxyXG5cdFx0XHRpZiAod2luZG93Lm5hdmlnYXRvci5nZW9sb2NhdGlvbikge1xyXG5cclxuXHRcdFx0XHRjb25zdCBwYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHRcdFx0ZW5hYmxlSGlnaEFjY3VyYWN5OiB0cnVlLFxyXG5cdFx0XHRcdFx0bWF4aW11bUFnZTogMzAwMDAsXHJcblx0XHRcdFx0XHR0aW1lb3V0OiAyNzAwMFxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bGV0IGdvdFBvc2l0aW9uT25jZSA9IGZhbHNlXHJcblxyXG5cdFx0XHRcdHdpbmRvdy5uYXZpZ2F0b3IuZ2VvbG9jYXRpb24ud2F0Y2hQb3NpdGlvbihcclxuXHRcdFx0XHRcdHBvc2l0aW9uID0+IHtcclxuXHJcblx0XHRcdFx0XHRcdHRoaXMucG9zaXRpb24gPSBwb3NpdGlvblxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCFnb3RQb3NpdGlvbk9uY2UpIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Z290UG9zaXRpb25PbmNlID0gdHJ1ZVxyXG5cclxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZygnR290IHBvc2l0aW9uIScsIHRoaXMucG9zaXRpb24pXHJcblxyXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoKVxyXG5cclxuXHRcdFx0XHRcdFx0fSBcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdCgpID0+IHJlamVjdChcIkxlIHNlcnZpY2UgZGUgZ8Opb2xvY2FsaXNhdGlvbiBuJ2VzdCBwYXMgZGlzcG9uaWJsZS5cIiksXHJcblx0XHRcdFx0XHRwYXJhbWV0ZXJzXHJcblx0XHRcdFx0KVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZWxzZSByZWplY3QoXCJMZSBzZXJ2aWNlIGRlIGfDqW9sb2NhbGlzYXRpb24gbidlc3QgcGFzIGRpc3BvbmlibGUuXCIpXHJcblxyXG5cdFx0fSlcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZW5kIGNvb3JkaW5hdGVzXHJcblx0ICovXHJcblx0c2VuZENvb3JkaW5hdGVzKCkge1xyXG5cclxuXHRcdGNvbnN0IHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvblxyXG5cclxuXHRcdGlmICh0aGlzLmNvbm5lY3RlZCAmJiBwb3NpdGlvbikge1xyXG5cclxuXHRcdFx0Y29uc29sZS5sb2coJ1NlbmRpbmcgbmV3IGNvb3JkcyB0byBzZXJ2ZXI6JywgcG9zaXRpb24uY29vcmRzKVxyXG5cclxuXHRcdFx0dGhpcy5zb2NrZXQuZW1pdCgnY29vcmRpbmF0ZXMnLCBwb3NpdGlvbi5jb29yZHMpXHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFxyXG5cdCAqL1xyXG5cdHVwZGF0ZSgpIHtcclxuXHJcblx0XHRjb25zdCBub3cgPSArbmV3IERhdGVcclxuXHJcblx0XHRpZiAodGhpcy5sYXN0Q29vcmRpbmF0ZXNTZW50VGltZSA8IG5vdyAtIDUwMDApIHtcclxuXHJcblx0XHRcdHRoaXMubGFzdENvb3JkaW5hdGVzU2VudFRpbWUgPSBub3dcclxuXHRcdFx0dGhpcy5zZW5kQ29vcmRpbmF0ZXMoKVxyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFcnJvclxyXG5cdCAqL1xyXG5cdGVycm9yKG1lc3NhZ2UpIHtcclxuXHJcblx0XHRjb25zb2xlLmVycm9yKG1lc3NhZ2UpXHJcblxyXG5cdH1cclxufSIsImltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcGFzcyB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcclxuXHRcdFxyXG5cdFx0dGhpcy5uZWVkbGVFbGVtZW50ID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcucmVkLm5lZWRsZScpXHJcblx0XHRcclxuXHRcdC8vIExhc3QgYW5nbGVcclxuXHRcdHRoaXMudGFyZ2V0ZWRBbmdsZSA9IDBcclxuXHJcblx0XHQvLyBWaXN1YWwgYW5nbGUgb2YgdGhlIG5lZWRsZVxyXG5cdFx0dGhpcy52aXNpYmxlQW5nbGUgPSAwXHJcblxyXG5cdFx0Ly8gTmVlZGxlIHZlbG9jaXR5IFxyXG5cdFx0dGhpcy52ZWxvY2l0eSA9IDBcclxuXHJcblx0XHQvLyBMYXN0IHRpbWUgYSBmcmFtZSB3YXMgdXBkYXRlZFxyXG5cdFx0dGhpcy5sYXN0VGltZSA9ICtuZXcgRGF0ZVxyXG5cclxuXHRcdC8vIExhc3QgdGltZSB0aGUgdmVsb2NpdHkgd2FzIHVwZGF0ZWRcclxuXHRcdHRoaXMubGFzdFZlbG9jaXR5VXBkYXRlVGltZSA9IC1JbmZpbml0eVxyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIMOJdsOobmVtZW50c1xyXG5cdCAqL1xyXG5cdHN0YXJ0KCkge1xyXG5cclxuXHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGUuYmluZCh0aGlzKSlcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBOb3V2ZWwgYW5nbGUgZG9ubsOpIHBhciBsZSBkZXZpY2VcclxuXHQgKiBAcGFyYW0gPE51bWJlcj4gYW5nbGVcclxuXHQgKi9cclxuXHRzZXQgYW5nbGUoYW5nbGUpIHtcclxuXHJcblx0XHRjb25zdCBub3cgPSArbmV3IERhdGVcclxuXHJcblx0XHQvLyBEaWZmZXJlbmNlIGJldHdlZW4gdGhlIGxhc3QgdHdvIGFuZ2xlc1xyXG5cdFx0bGV0IGRpZmYgPSB1dGlscy5jYWxjdWxhdGVBbmdsZUJldHdlZW5EaXJlY3Rpb25zKGFuZ2xlLCB0aGlzLnRhcmdldGVkQW5nbGUpXHJcblxyXG5cdFx0Ly8gTmV3IGFuZ2xlIC0rSW5maW5pXHJcblx0XHQvLyB0byBhdm9pZCBzdHJhbmdlIHRyYW5zaXRpb25zXHJcblx0XHQvLyAodGhlIG5lZWRsZSBkb2luZyBhIGZ1bGwgY2lyY2xlIGJldHdlZW4gMzUwwrAgYW5kIDEwwrAsIGZvciBleGFtcGxlKVxyXG5cdFx0dGhpcy50YXJnZXRlZEFuZ2xlICs9IGRpZmZcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQqIEByZXR1cm4gPE51bWJlcj5cclxuXHQgKi9cclxuXHRnZXQgYW5nbGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudGFyZ2V0ZWRBbmdsZVxyXG5cclxuXHR9XHJcblxyXG5cdC8qKiBcclxuXHQgKiBVcGRhdGluZyB2ZWxvY2l0eVxyXG5cdCAqIFNlcGFyYXRlIGZyb20gZGlzcGxheSB1cGRhdGUgZm9yIHBlcmZvcm1hbmNlXHJcblx0ICovXHJcblx0dXBkYXRlVmVsb2NpdHkoKSB7XHJcblxyXG5cdFx0Y29uc3QgZGlmZiA9IHV0aWxzLmNhbGN1bGF0ZUFuZ2xlQmV0d2VlbkRpcmVjdGlvbnModGhpcy50YXJnZXRlZEFuZ2xlLCB0aGlzLnZpc2libGVBbmdsZSlcclxuXHRcdFxyXG5cdFx0dGhpcy52ZWxvY2l0eSA9IHRoaXMudmVsb2NpdHkgKiAwLjUgKyBkaWZmICogMlxyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSB2aXNpYmxlIGFuZ2xlIG9mIHRoZSBuZWVkbGVcclxuXHQgKiBAcGFyYW0gPE51bWJlcj4gdGltZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZSh0aW1lKSB7XHJcblxyXG5cdFx0dGhpcy52aXNpYmxlQW5nbGUgKz0gdGhpcy52ZWxvY2l0eSAqICgodGltZSAtIHRoaXMubGFzdFRpbWUpIC8gMTAwMClcclxuXHJcblx0XHR0aGlzLm5lZWRsZUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHJvdGF0ZSgke3RoaXMudmlzaWJsZUFuZ2xlfWRlZylgXHJcblxyXG5cdFx0dGhpcy5sYXN0VGltZSA9IHRpbWVcclxuXHJcblx0XHRpZiAodGltZSAtIHRoaXMubGFzdFZlbG9jaXR5VXBkYXRlVGltZSA+IDIwMCkge1xyXG5cclxuXHRcdFx0dGhpcy5sYXN0VmVsb2NpdHlVcGRhdGVUaW1lID0gdGltZVxyXG5cdFx0XHRcclxuXHRcdFx0dGhpcy51cGRhdGVWZWxvY2l0eSgpXHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGUuYmluZCh0aGlzKSlcclxuXHJcblx0fVxyXG5cclxufSIsImltcG9ydCBDbGllbnQgZnJvbSAnLi9jbGllbnQnXHJcblxyXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZXZlbnQgPT4ge1xyXG5cclxuXHRjb25zdCBjbGllbnQgPSBuZXcgQ2xpZW50XHJcblxyXG5cdGNsaWVudC5zdGFydCgpXHJcblxyXG59KSIsImV4cG9ydCBkZWZhdWx0IHtcclxuXHJcblx0LyoqXHJcblx0ICogQ2FsY3VsYXRlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gYW5nbGVzICgzNjApXHJcblx0ICogQHBhcmFtIDxOdW1iZXI+IG9yaWdpblxyXG5cdCAqIEBwYXJhbSA8TnVtYmVyPiB0YXJnZXRcclxuXHQgKiBAcmV0dXJuIDxOdW1iZXI+XHJcblx0ICovXHJcblx0Y2FsY3VsYXRlQW5nbGVCZXR3ZWVuRGlyZWN0aW9ucyhvcmlnaW4sIHRhcmdldCkge1xyXG5cclxuXHRcdGNvbnN0IG4gPSBvcmlnaW4gLSB0YXJnZXQgKyAxODBcclxuXHJcblx0XHRyZXR1cm4gKG4gLSBNYXRoLmZsb29yKG4gLyAzNjApICogMzYwKSAtIDE4MFxyXG5cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDYWxjdWxhdGUgYW5nbGUgYmV0d2VlbiB0d28gY29vcmRpbmF0ZXNcclxuXHQgKiBAcGFyYW0gPENvb3JkaW5hdGVzPiBvcmlnaW5cclxuXHQgKiBAcGFyYW0gPENvb3JkaW5hdGVzPiB0YXJnZXRcclxuXHQgKiBAcmV0dXJuIDxOdW1iZXI+IGFuZ2xlIGluIGRlZ3JlZXNcclxuXHQgKi9cclxuXHRjYWxjdWxhdGVEaXJlY3Rpb25Ub0Nvb3JkaW5hdGVzKG9yaWdpbiwgdGFyZ2V0KSB7XHJcblxyXG5cdFx0Y29uc3QgY29zID0gTWF0aC5jb3MsIHNpbiA9IE1hdGguc2luXHJcblxyXG5cdFx0Y29uc3QgZGlzdGFuY2UgPSAodGFyZ2V0LmxvbmdpdHVkZSAtIG9yaWdpbi5sb25naXR1ZGUpXHJcblxyXG5cdFx0Y29uc3QgeSA9IHNpbihkaXN0YW5jZSkgKiBjb3ModGFyZ2V0LmxhdGl0dWRlKVxyXG5cclxuXHRcdGNvbnN0IHggPSBjb3Mob3JpZ2luLmxhdGl0dWRlKSAqIHNpbih0YXJnZXQubGF0aXR1ZGUpXHJcblx0XHRcdFx0LSBzaW4ob3JpZ2luLmxhdGl0dWRlKSAqIGNvcyh0YXJnZXQubGF0aXR1ZGUpXHJcblx0XHRcdFx0KiBjb3MoZGlzdGFuY2UpXHJcblxyXG5cdCAgICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKHksIHgpXHJcblxyXG5cdCAgICAvLyBSYWRpYW5zIHRvIGRlZ3JlZXNcclxuXHQgICAgYW5nbGUgKj0gMTgwIC8gTWF0aC5QSVxyXG5cclxuXHQgICAgYW5nbGUgPSAoYW5nbGUgKyAzNjApICUgMzYwXHJcblxyXG5cdCAgICBhbmdsZSA9IDM2MCAtIGFuZ2xlOyAvLyBjb3VudCBkZWdyZWVzIGNvdW50ZXItY2xvY2t3aXNlIC0gcmVtb3ZlIHRvIG1ha2UgY2xvY2t3aXNlXHJcblxyXG5cdCAgICByZXR1cm4gYW5nbGU7XHJcblx0fVxyXG5cclxufSJdfQ==
