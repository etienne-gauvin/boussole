(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
		value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Compass = function () {
		function Compass(element) {
				_classCallCheck(this, Compass);

				this.needleElement = element.querySelector('.red.needle');

				// Last angle
				this.targetedAngle = 0;

				// Visual angle of the needle
				this.visibleAngle = 0;

				// Needle velocity 
				this.velocity = 0;

				// Last time a frame was updated
				this.lastTime = +new Date();

				// Last time the velocity was updated
				this.lastVelocityUpdateTime = -Infinity;
		}

		/**
   * Évènements
   */


		_createClass(Compass, [{
				key: 'start',
				value: function start() {

						window.requestAnimationFrame(this.update.bind(this));
				}

				/**
     * Nouvel angle donné par le device
     * @param <Number> angle
     */

		}, {
				key: 'updateVelocity',


				/** 
     * Updating velocity
     * Separate from display update for performance
     */
				value: function updateVelocity() {

						var diff = _utils2.default.calculateAngleBetweenDirections(this.targetedAngle, this.visibleAngle);

						this.velocity = this.velocity * 0.5 + diff * 2;
				}

				/**
     * Update visible angle of the needle
     * @param <Number> time
     */

		}, {
				key: 'update',
				value: function update(time) {

						this.visibleAngle += this.velocity * ((time - this.lastTime) / 1000);

						this.needleElement.style.transform = 'rotate(' + this.visibleAngle + 'deg)';

						this.lastTime = time;

						if (time - this.lastVelocityUpdateTime > 200) {

								this.lastVelocityUpdateTime = time;

								this.updateVelocity();
						}

						window.requestAnimationFrame(this.update.bind(this));
				}
		}, {
				key: 'angle',
				set: function set(angle) {

						var now = +new Date();

						// Difference between the last two angles
						var diff = _utils2.default.calculateAngleBetweenDirections(angle, this.targetedAngle);

						// New angle -+Infini
						// to avoid strange transitions
						// (the needle doing a full circle between 350° and 10°, for example)
						this.targetedAngle += diff;
				}

				/**
    * @return <Number>
     */
				,
				get: function get() {

						return this.targetedAngle;
				}
		}]);

		return Compass;
}();

exports.default = Compass;

},{"./utils":3}],2:[function(require,module,exports){
'use strict';

var _compass = require('./compass');

var _compass2 = _interopRequireDefault(_compass);

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

document.addEventListener("DOMContentLoaded", function (event) {

	var deviceDirection = 0;
	var directionToTarget = 0;

	var compass = new _compass2.default(document.querySelector('.compass'));
	compass.start();

	if (window.DeviceOrientationEvent) {

		window.addEventListener('deviceorientation', function (event) {

			deviceDirection = event.alpha;

			update();
		});
	} else console.error("La boussole n'est pas disponible.");

	if (window.navigator.geolocation) {

		window.navigator.geolocation.watchPosition(onPositionUpdateSuccess, onPositionUpdateError, {
			enableHighAccuracy: true,
			maximumAge: 30000,
			timeout: 27000
		});
	} else console.error("Le service de géolocalisation n'est pas disponible.");

	function onPositionUpdateSuccess(position) {

		var a = { latitude: 48.117342, longitude: -1.708520 };
		var b = { latitude: 48.117086, longitude: -1.696259 };

		console.log(position);

		// directionToTarget = utils.calculateDirectionToCoordinates(a, b);
		directionToTarget = _utils2.default.calculateDirectionToCoordinates(position.coords, b);

		update();
	}

	function onPositionUpdateError(error) {
		console.log(error);
	}

	function update() {

		compass.angle = deviceDirection + directionToTarget;
	}
});

},{"./compass":1,"./utils":3}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = {

	/**
  * Calculate difference between two angles (360)
  * @param <Number> origin
  * @param <Number> target
  * @return <Number>
  */
	calculateAngleBetweenDirections: function calculateAngleBetweenDirections(origin, target) {

		var n = origin - target + 180;

		return n - Math.floor(n / 360) * 360 - 180;
	},


	/**
  * Calculate angle between two coordinates
  * @param <Coordinates> origin
  * @param <Coordinates> target
  * @return <Number> angle in degrees
  */
	calculateDirectionToCoordinates: function calculateDirectionToCoordinates(origin, target) {

		var cos = Math.cos,
		    sin = Math.sin;

		var distance = target.longitude - origin.longitude;

		var y = sin(distance) * cos(target.latitude);

		var x = cos(origin.latitude) * sin(target.latitude) - sin(origin.latitude) * cos(target.latitude) * cos(distance);

		var angle = Math.atan2(y, x);

		// Radians to degrees
		angle *= 180 / Math.PI;

		angle = (angle + 360) % 360;

		angle = 360 - angle; // count degrees counter-clockwise - remove to make clockwise

		return angle;
	}
};

},{}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3dhdGNoaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjbGllbnRcXGphdmFzY3JpcHRzXFxjb21wYXNzLmpzIiwiY2xpZW50XFxqYXZhc2NyaXB0c1xcc2NyaXB0LmpzIiwiY2xpZW50XFxqYXZhc2NyaXB0c1xcdXRpbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7OztBQ0FBOzs7Ozs7OztJQUVxQixPO0FBRXBCLG1CQUFZLE9BQVosRUFBcUI7QUFBQTs7QUFFcEIsU0FBSyxhQUFMLEdBQXFCLFFBQVEsYUFBUixDQUFzQixhQUF0QixDQUFyQjs7QUFFQTtBQUNBLFNBQUssYUFBTCxHQUFxQixDQUFyQjs7QUFFQTtBQUNBLFNBQUssWUFBTCxHQUFvQixDQUFwQjs7QUFFQTtBQUNBLFNBQUssUUFBTCxHQUFnQixDQUFoQjs7QUFFQTtBQUNBLFNBQUssUUFBTCxHQUFnQixDQUFDLElBQUksSUFBSixFQUFqQjs7QUFFQTtBQUNBLFNBQUssc0JBQUwsR0FBOEIsQ0FBQyxRQUEvQjtBQUVBOztBQUVEOzs7Ozs7OzRCQUdROztBQUVQLGFBQU8scUJBQVAsQ0FBNkIsS0FBSyxNQUFMLENBQVksSUFBWixDQUFpQixJQUFqQixDQUE3QjtBQUVBOztBQUVEOzs7Ozs7Ozs7QUEyQkE7Ozs7cUNBSWlCOztBQUVoQixVQUFNLE9BQU8sZ0JBQU0sK0JBQU4sQ0FBc0MsS0FBSyxhQUEzQyxFQUEwRCxLQUFLLFlBQS9ELENBQWI7O0FBRUEsV0FBSyxRQUFMLEdBQWdCLEtBQUssUUFBTCxHQUFnQixHQUFoQixHQUFzQixPQUFPLENBQTdDO0FBRUE7O0FBRUQ7Ozs7Ozs7MkJBSU8sSSxFQUFNOztBQUVaLFdBQUssWUFBTCxJQUFxQixLQUFLLFFBQUwsSUFBaUIsQ0FBQyxPQUFPLEtBQUssUUFBYixJQUF5QixJQUExQyxDQUFyQjs7QUFFQSxXQUFLLGFBQUws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LElBQUksT0FBTyxRQUFYLElBQXVCLElBQUksT0FBTyxRQUFYLENBQXZCLEdBQ04sSUFBSSxPQUFPLFFBQVgsSUFBdUIsSUFBSSxPQUFPLFFBQVgsQ0FBdkIsR0FDQSxJQUFJLFFBQUosQ0FGSjs7QUFJRyxNQUFJLFFBQVEsS0FBSyxLQUFMLENBQVcsQ0FBWCxFQUFjLENBQWQsQ0FBWjs7QUFFQTtBQUNBLFdBQVMsTUFBTSxLQUFLLEVBQXBCOztBQUVBLFVBQVEsQ0FBQyxRQUFRLEdBQVQsSUFBZ0IsR0FBeEI7O0FBRUEsVUFBUSxNQUFNLEtBQWQsQ0FuQjRDLENBbUJ2Qjs7QUFFckIsU0FBTyxLQUFQO0FBQ0g7QUE1Q2EsQyIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJpbXBvcnQgdXRpbHMgZnJvbSAnLi91dGlscydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBhc3Mge1xyXG5cclxuXHRjb25zdHJ1Y3RvcihlbGVtZW50KSB7XHJcblx0XHRcclxuXHRcdHRoaXMubmVlZGxlRWxlbWVudCA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignLnJlZC5uZWVkbGUnKVxyXG5cdFx0XHJcblx0XHQvLyBMYXN0IGFuZ2xlXHJcblx0XHR0aGlzLnRhcmdldGVkQW5nbGUgPSAwXHJcblxyXG5cdFx0Ly8gVmlzdWFsIGFuZ2xlIG9mIHRoZSBuZWVkbGVcclxuXHRcdHRoaXMudmlzaWJsZUFuZ2xlID0gMFxyXG5cclxuXHRcdC8vIE5lZWRsZSB2ZWxvY2l0eSBcclxuXHRcdHRoaXMudmVsb2NpdHkgPSAwXHJcblxyXG5cdFx0Ly8gTGFzdCB0aW1lIGEgZnJhbWUgd2FzIHVwZGF0ZWRcclxuXHRcdHRoaXMubGFzdFRpbWUgPSArbmV3IERhdGVcclxuXHJcblx0XHQvLyBMYXN0IHRpbWUgdGhlIHZlbG9jaXR5IHdhcyB1cGRhdGVkXHJcblx0XHR0aGlzLmxhc3RWZWxvY2l0eVVwZGF0ZVRpbWUgPSAtSW5maW5pdHlcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiDDiXbDqG5lbWVudHNcclxuXHQgKi9cclxuXHRzdGFydCgpIHtcclxuXHJcblx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlLmJpbmQodGhpcykpXHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogTm91dmVsIGFuZ2xlIGRvbm7DqSBwYXIgbGUgZGV2aWNlXHJcblx0ICogQHBhcmFtIDxOdW1iZXI+IGFuZ2xlXHJcblx0ICovXHJcblx0c2V0IGFuZ2xlKGFuZ2xlKSB7XHJcblxyXG5cdFx0Y29uc3Qgbm93ID0gK25ldyBEYXRlXHJcblxyXG5cdFx0Ly8gRGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBsYXN0IHR3byBhbmdsZXNcclxuXHRcdGxldCBkaWZmID0gdXRpbHMuY2FsY3VsYXRlQW5nbGVCZXR3ZWVuRGlyZWN0aW9ucyhhbmdsZSwgdGhpcy50YXJnZXRlZEFuZ2xlKVxyXG5cclxuXHRcdC8vIE5ldyBhbmdsZSAtK0luZmluaVxyXG5cdFx0Ly8gdG8gYXZvaWQgc3RyYW5nZSB0cmFuc2l0aW9uc1xyXG5cdFx0Ly8gKHRoZSBuZWVkbGUgZG9pbmcgYSBmdWxsIGNpcmNsZSBiZXR3ZWVuIDM1MMKwIGFuZCAxMMKwLCBmb3IgZXhhbXBsZSlcclxuXHRcdHRoaXMudGFyZ2V0ZWRBbmdsZSArPSBkaWZmXHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0KiBAcmV0dXJuIDxOdW1iZXI+XHJcblx0ICovXHJcblx0Z2V0IGFuZ2xlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnRhcmdldGVkQW5nbGVcclxuXHJcblx0fVxyXG5cclxuXHQvKiogXHJcblx0ICogVXBkYXRpbmcgdmVsb2NpdHlcclxuXHQgKiBTZXBhcmF0ZSBmcm9tIGRpc3BsYXkgdXBkYXRlIGZvciBwZXJmb3JtYW5jZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZVZlbG9jaXR5KCkge1xyXG5cclxuXHRcdGNvbnN0IGRpZmYgPSB1dGlscy5jYWxjdWxhdGVBbmdsZUJldHdlZW5EaXJlY3Rpb25zKHRoaXMudGFyZ2V0ZWRBbmdsZSwgdGhpcy52aXNpYmxlQW5nbGUpXHJcblx0XHRcclxuXHRcdHRoaXMudmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5ICogMC41ICsgZGlmZiAqIDJcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgdmlzaWJsZSBhbmdsZSBvZiB0aGUgbmVlZGxlXHJcblx0ICogQHBhcmFtIDxOdW1iZXI+IHRpbWVcclxuXHQgKi9cclxuXHR1cGRhdGUodGltZSkge1xyXG5cclxuXHRcdHRoaXMudmlzaWJsZUFuZ2xlICs9IHRoaXMudmVsb2NpdHkgKiAoKHRpbWUgLSB0aGlzLmxhc3RUaW1lKSAvIDEwMDApXHJcblxyXG5cdFx0dGhpcy5uZWVkbGVFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IGByb3RhdGUoJHt0aGlzLnZpc2libGVBbmdsZX1kZWcpYFxyXG5cclxuXHRcdHRoaXMubGFzdFRpbWUgPSB0aW1lXHJcblxyXG5cdFx0aWYgKHRpbWUgLSB0aGlzLmxhc3RWZWxvY2l0eVVwZGF0ZVRpbWUgPiAyMDApIHtcclxuXHJcblx0XHRcdHRoaXMubGFzdFZlbG9jaXR5VXBkYXRlVGltZSA9IHRpbWVcclxuXHRcdFx0XHJcblx0XHRcdHRoaXMudXBkYXRlVmVsb2NpdHkoKVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlLmJpbmQodGhpcykpXHJcblxyXG5cdH1cclxuXHJcbn0iLCJpbXBvcnQgQ29tcGFzcyBmcm9tICcuL2NvbXBhc3MnXHJcbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzJ1xyXG5cclxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKGV2ZW50KSA9PiB7XHJcblxyXG5cdGxldCBkZXZpY2VEaXJlY3Rpb24gPSAwXHJcblx0bGV0IGRpcmVjdGlvblRvVGFyZ2V0ID0gMFxyXG5cclxuXHRjb25zdCBjb21wYXNzID0gbmV3IENvbXBhc3MoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbXBhc3MnKSlcclxuXHRjb21wYXNzLnN0YXJ0KClcclxuXHJcblx0aWYgKHdpbmRvdy5EZXZpY2VPcmllbnRhdGlvbkV2ZW50KSB7XHJcblxyXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZW9yaWVudGF0aW9uJywgKGV2ZW50KSA9PiB7XHJcblx0XHRcclxuXHRcdFx0ZGV2aWNlRGlyZWN0aW9uID0gZXZlbnQuYWxwaGFcclxuXHJcblx0XHRcdHVwZGF0ZSgpXHJcblxyXG5cdFx0fSlcclxuXHJcblx0fVxyXG5cclxuXHRlbHNlIGNvbnNvbGUuZXJyb3IoXCJMYSBib3Vzc29sZSBuJ2VzdCBwYXMgZGlzcG9uaWJsZS5cIilcclxuXHJcblx0aWYgKHdpbmRvdy5uYXZpZ2F0b3IuZ2VvbG9jYXRpb24pIHtcclxuXHJcblx0XHR3aW5kb3cubmF2aWdhdG9yLmdlb2xvY2F0aW9uLndhdGNoUG9zaXRpb24oXHJcblx0XHRcdG9uUG9zaXRpb25VcGRhdGVTdWNjZXNzLFxyXG5cdFx0XHRvblBvc2l0aW9uVXBkYXRlRXJyb3IsXHJcblx0XHRcdHtcclxuXHRcdFx0XHRlbmFibGVIaWdoQWNjdXJhY3k6IHRydWUsXHJcblx0XHRcdFx0bWF4aW11bUFnZTogMzAwMDAsXHJcblx0XHRcdFx0dGltZW91dDogMjcwMDBcclxuXHRcdFx0fVxyXG5cdFx0KVxyXG5cclxuXHR9XHJcblx0ZWxzZSBjb25zb2xlLmVycm9yKFwiTGUgc2VydmljZSBkZSBnw6lvbG9jYWxpc2F0aW9uIG4nZXN0IHBhcyBkaXNwb25pYmxlLlwiKVxyXG5cclxuXHRmdW5jdGlvbiBvblBvc2l0aW9uVXBkYXRlU3VjY2Vzcyhwb3NpdGlvbikge1xyXG5cclxuXHRcdGNvbnN0IGEgPSB7IGxhdGl0dWRlOiA0OC4xMTczNDIsIGxvbmdpdHVkZTogLTEuNzA4NTIwIH1cclxuXHRcdGNvbnN0IGIgPSB7IGxhdGl0dWRlOiA0OC4xMTcwODYsIGxvbmdpdHVkZTogLTEuNjk2MjU5IH1cclxuXHJcblx0XHRjb25zb2xlLmxvZyhwb3NpdGlvbilcclxuXHJcblx0XHQvLyBkaXJlY3Rpb25Ub1RhcmdldCA9IHV0aWxzLmNhbGN1bGF0ZURpcmVjdGlvblRvQ29vcmRpbmF0ZXMoYSwgYik7XHJcblx0XHRkaXJlY3Rpb25Ub1RhcmdldCA9IHV0aWxzLmNhbGN1bGF0ZURpcmVjdGlvblRvQ29vcmRpbmF0ZXMocG9zaXRpb24uY29vcmRzLCBiKTtcclxuXHJcblx0XHR1cGRhdGUoKVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG9uUG9zaXRpb25VcGRhdGVFcnJvcihlcnJvcikge1xyXG5cdFx0Y29uc29sZS5sb2coZXJyb3IpXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB1cGRhdGUoKSB7XHJcblxyXG5cdFx0Y29tcGFzcy5hbmdsZSA9IGRldmljZURpcmVjdGlvbiArIGRpcmVjdGlvblRvVGFyZ2V0XHJcblxyXG5cdH1cclxuXHJcbn0pIiwiZXhwb3J0IGRlZmF1bHQge1xyXG5cclxuXHQvKipcclxuXHQgKiBDYWxjdWxhdGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBhbmdsZXMgKDM2MClcclxuXHQgKiBAcGFyYW0gPE51bWJlcj4gb3JpZ2luXHJcblx0ICogQHBhcmFtIDxOdW1iZXI+IHRhcmdldFxyXG5cdCAqIEByZXR1cm4gPE51bWJlcj5cclxuXHQgKi9cclxuXHRjYWxjdWxhdGVBbmdsZUJldHdlZW5EaXJlY3Rpb25zKG9yaWdpbiwgdGFyZ2V0KSB7XHJcblxyXG5cdFx0Y29uc3QgbiA9IG9yaWdpbiAtIHRhcmdldCArIDE4MFxyXG5cclxuXHRcdHJldHVybiAobiAtIE1hdGguZmxvb3IobiAvIDM2MCkgKiAzNjApIC0gMTgwXHJcblxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGN1bGF0ZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xyXG5cdCAqIEBwYXJhbSA8Q29vcmRpbmF0ZXM+IG9yaWdpblxyXG5cdCAqIEBwYXJhbSA8Q29vcmRpbmF0ZXM+IHRhcmdldFxyXG5cdCAqIEByZXR1cm4gPE51bWJlcj4gYW5nbGUgaW4gZGVncmVlc1xyXG5cdCAqL1xyXG5cdGNhbGN1bGF0ZURpcmVjdGlvblRvQ29vcmRpbmF0ZXMob3JpZ2luLCB0YXJnZXQpIHtcclxuXHJcblx0XHRjb25zdCBjb3MgPSBNYXRoLmNvcywgc2luID0gTWF0aC5zaW5cclxuXHJcblx0XHRjb25zdCBkaXN0YW5jZSA9ICh0YXJnZXQubG9uZ2l0dWRlIC0gb3JpZ2luLmxvbmdpdHVkZSlcclxuXHJcblx0XHRjb25zdCB5ID0gc2luKGRpc3RhbmNlKSAqIGNvcyh0YXJnZXQubGF0aXR1ZGUpXHJcblxyXG5cdFx0Y29uc3QgeCA9IGNvcyhvcmlnaW4ubGF0aXR1ZGUpICogc2luKHRhcmdldC5sYXRpdHVkZSlcclxuXHRcdFx0XHQtIHNpbihvcmlnaW4ubGF0aXR1ZGUpICogY29zKHRhcmdldC5sYXRpdHVkZSlcclxuXHRcdFx0XHQqIGNvcyhkaXN0YW5jZSlcclxuXHJcblx0ICAgIGxldCBhbmdsZSA9IE1hdGguYXRhbjIoeSwgeClcclxuXHJcblx0ICAgIC8vIFJhZGlhbnMgdG8gZGVncmVlc1xyXG5cdCAgICBhbmdsZSAqPSAxODAgLyBNYXRoLlBJXHJcblxyXG5cdCAgICBhbmdsZSA9IChhbmdsZSArIDM2MCkgJSAzNjBcclxuXHJcblx0ICAgIGFuZ2xlID0gMzYwIC0gYW5nbGU7IC8vIGNvdW50IGRlZ3JlZXMgY291bnRlci1jbG9ja3dpc2UgLSByZW1vdmUgdG8gbWFrZSBjbG9ja3dpc2VcclxuXHJcblx0ICAgIHJldHVybiBhbmdsZTtcclxuXHR9XHJcblxyXG59Il19
